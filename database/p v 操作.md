### 一、什么是PV操作?

PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下： P（S）： ①将信号量S的值减1，即S=S-1； ②如果S>0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。

V（S）： ①将信号量S的值加1，即S=S+1；

## 二、PV操作的意义：

我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。

## 三、什么是信号量？

信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。 **信号量的值与相应资源的使用情况有关:** ①: 当信号量的值大于0时，表示当前可用资源的数量 ②: 当它的值小于0时，其绝对值表示等待使用该资源的进程个数 **注意，信号量的值仅能由PV操作来改变。**

## 四、使用PV操作注意事项：

①: 每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。 ②: P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。 ③: 互斥信号量的初值一般为1。

## 五、PV操作实例:

## 5.1 例题1: 吃苹果问题:



![img](https://pic3.zhimg.com/80/v2-78698599de205aba5272a162b2006f4e_1440w.webp)



**解题过程:**

```c
semaphore empty=2； //定义empty对应盘子的剩余放水果的位置个数初值为2(      空缓冲区个数       ) 
    semaphore apple=0； //定义信号量apple对应盘子里的苹果数量初值为0 
    semaphore orange=0； //定义信号量orange对于盘子里的橘子数量初值为0 
    semaphore mutex=1： //定义信号量mutex来保护盘子被互斥地访问 
    father(){ //爸爸进程
    while(1){ 
        P(empty)； //盘子的剩余放水果的位置减一，如果>=0,说明有位置可以放苹果
            P(mutex)； 
            在盘子里放一个苹果 
            V(mutex)； 
            V(apple)；//盘中苹果数加一
    }
}


mother(){ //妈妈进程 
    while(1)  { 
        P(empty)； //盘子的剩余放水果的位置减一，如果>=0,说明有位置可以放橘子
            P(mutex)； //互斥变量减一，如果<0，则说明有进程在临界区。则当前进程必须等待。
            在盘子里放一个橘子
            V(mutex)； 进程执行完毕，出了临界区，互斥变量值加一。
            V(orange)； //盘中橘子数加一
    } 
} 

son(){ //用这段程序产生两个儿子进程 
    while(1)  { 
        P(orange)； //盘中橘子个数减一，如果结果>=0时,说明盘中有橘子，可以取 
            P(mutex)； 
            从盘子里拿一个橘子
            V(mutex)； 
            V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一
    }
}
daughter(){ //用这段程序产生两个女儿进程 
    while(1 )  { 
        P(apple)；   //盘中苹果个数减一，如果结果>=0时,说明盘中有苹果，可以取
            P(mutex)； 
            从盘子里拿出一个苹果 
            V(mutex)；
            V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一

    } 
}
```

### 5.2 : 和尚打水:



![img](https://pic4.zhimg.com/80/v2-8be3dee9494cab922d36840692f9203b_1440w.webp)



**分析:**



![img](https://pic1.zhimg.com/80/v2-b180c503e7b48734783dafd193dc91a8_1440w.webp)



**解题过程:**

```c
Semaphore   mutexA = 1;    //保护井被互斥地访问 
Semaphore   mutexB = 1;    //保护缸被互斥地访问 
Semaphore   Count = 3；    //桶总数为3
Semaphore   full = 0;      //控制出水，刚开始，缸是空的，能取出0桶水
Semaphore   empty = 10 ;   //控制入水，刚开始，缸是空的，能倒入10桶水

//小和尚打水：
Progress（小和尚）{
          while（1）{
                   P（empty）  //判断缸是否满了（结果如果>=0,未满），决定是否需要打水
                   P（count）  //拿桶（判断是否有空闲的桶，结果如果>=0,有桶）
                   P（mutexA）{   //对井互斥访问
                    从井中打水；
                    V（mutexA）    //互斥
                   }

                    P（mutexB）{   //对缸互斥访问
                    向缸中倒水；
                    V（mutexB）    //互斥
                   }
                   V（count）//还桶，空闲桶的数量加一
                   V（full）   //缸中水的数量加一，（通知老和尚取水）
          }
}

//老和尚取水：
progress（老和尚）{
             while（1）{
                      P（full） //判断缸中是否有水，（结果如果>=0,说明缸中有水，可取水）
                      P（count）//拿桶
                      P（mutexB) //互斥
                      从缸中取水；
                      V（mutexB）//互斥
                      V(count)   //还桶
                      V（empty）//缸中还能容纳的水数量加一，（通知小和尚打水）
             }
}
```