# [MD5算法的应用](https://www.cnblogs.com/henryhappier/archive/2011/03/15/1984730.html)

#### MD5算法的应用

##### 对信息产生摘要

　　MD5的典型应用是对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。比如，在UNIX下有很多软件在下载的时候都有一个文件名相同，文件扩展名为.md5的文件，在这个文件中通常只有一行文本，大致结构如：

　　MD5 (tanajiya.tar.gz) = 0ca175b9c0f726a831d895e269332461

　　这就是tanajiya.tar.gz文件的数字签名。MD5将整个文件当作一个大文本信息，通过其不可逆的字符串变换算法，产生了这个唯一的MD5信息摘要。为了让读者朋友对MD5的应用有个直观的认识，笔者以一个比方和一个实例来简要描述一下其工作过程：

　　大家都知道，地球上任何人都有自己独一无二的[指纹](http://baike.baidu.com/view/5628.htm)，这常常成为公安机关鉴别罪犯身份最值得信赖的方法；与之类似，MD5就可以为任何文件（不管其大小、格式、数量）产生一个同样独一无二的“[数字指纹](http://baike.baidu.com/view/962481.htm)”，如果任何人对文件做了任何改动，其[MD5值](http://baike.baidu.com/view/1047696.htm)也就是对应的“数字指纹”都会发生变化。

　　我们常常在某些软件下载站点的某软件信息中看到其MD5值，它的作用就在于我们可以在下载该软件后，对下载回来的文件用专门的软件（如Windows MD5 Check等）做一次[MD5校验](http://baike.baidu.com/view/274197.htm)，以确保我们获得的文件与该站点提供的文件为同一文件。利用MD5算法来进行文件校验的方案被大量应用到软件下载站、论坛数据库、[系统文件](http://baike.baidu.com/view/1152855.htm)安全等方面。

 

##### 对字节串产生指纹

　　MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹)，以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现（两个MD5值不相同）。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。

#####  

##### 登录认证

　　MD5还广泛用于[操作系统](http://baike.baidu.com/view/880.htm)的登陆认证上，如Unix、各类[BSD系统](http://baike.baidu.com/view/4225732.htm)登录密码、数字签名等诸多方。如在UNIX系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这可以避免用户的密码被具有系统管理员权限的用户知道。MD5将任意长度的“字节串”映射为一个128bit的大整数，并且是通过该128bit反推原始字符串是困难的，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。所以，要遇到了md5密码的问题，比较好的办法是：你可以用这个系统中的md5()函数重新设一个密码，如admin，把生成的一串密码的Hash值覆盖原来的Hash值就行了。

　　正是因为这个原因，现在被黑客使用最多的一种破译密码的方法就是一种被称为"跑字典"的方法。有两种方法得到字典，一种是日常搜集的用做密码的字符串表，另一种是用排列组合方法生成的，先用MD5程序计算出这些字典项的MD5值，然后再用目标的MD5值在这个字典中检索。我们假设密码的最大长度为8位字节（8 Bytes），同时密码只能是字母和数字，共26+26+10=62个字符，排列组合出的字典的项数则是P(62,1)+P(62,2)….+P(62,8)，那也已经是一个很天文的数字了，存储这个字典就需要TB级的磁盘阵列，而且这种方法还有一个前提，就是能获得目标账户的密码MD5值的情况下才可以。这种加密技术被广泛的应用于UNIX系统中，这也是为什么UNIX系统比一般操作系统更为坚固一个重要原因。





**哈希算法有很多，包括但不限于：**

1. MD5(Massage Digest Algorithm): 它会接收信息，并返回一个固定长度128位的哈希值。
2. SHA(Secure Hash Algorithm)系列：其中包括SHA-1，SHA-256，SHA-512等，它们返回的哈希值长度分别是160位，256位，512位。
3. CRC32(Cyclic Redundancy Check): 主要用于数据的错误检测。
4. MurmurHash：非加密哈希函数，广泛用于哈希表中。
5. 基于模运算的哈希函数：例如，Java的HashSet和HashMap中采用的hash函数。

以下是一个简单的哈希函数的例子：

```python
python复制
def hash_function(key, size):
    return key % size

# 测试
print(hash_function(10, 5))  # 输出：0
print(hash_function(15, 5))  # 输出：0
print(hash_function(20, 5))  # 输出：0
print(hash_function(25, 5))  # 输出：0
```

这个函数很简单，它返回键除以表大小的余数。哈希表的大小（size）常选为质数，这有助于减少哈希冲突。但是，这个哈希函数太简单，可能会导致很多哈希冲突，实际使用时，常常会选择复杂一些、分布更均匀的哈希函数。

注意这个函数只适用于处理整数键，如果键是字符串或其他非数字类型，可能需要更复杂的函数，例如：先对每个字符进行适当的转换，再进行运算。



**涉及大数据量且要求较低哈希冲突的场景，通常需要采用多哈希函数或者哈希函数族。这就是说我们需要不止一个哈希函数，而是一系列哈希函数，每个哈希函数都会对数据进行一次独立的映射。**

一个简单但相对有效的方式是采用MurmurHash与FNV哈希函数的组合。这两种哈希函数都是非加密哈希函数，运算速度快且哈希质量高。具体实现需要首先将你的输入转化为字节流，然后使用特定的哈希函数进行映射。在Python中可以使用`mmh3`模块和`fnvhash`模块获取MurmurHash和FNV哈希的值。

下面是一个使用MurmurHash的示例：

```python
python复制
import mmh3

def hash_function1(input_str, filter_size):
    return mmh3.hash(input_str, 41) % filter_size
```

下面是一个使用FNV哈希的示例：

```python
python复制
import fnvhash

def hash_function2(input_str, filter_size):
    return fnvhash.fnv1a_64(input_str.encode('utf-8')) % filter_size
```

在真实布隆过滤器的实现中，会同时使用好几个这样的哈希函数进行映射，以减少误判率。

在设计哈希函数时，还需要考虑一个约束：哈希函数计算需要稍微复杂一点，以保证生成的哈希值分布更均匀，但也不能设计得过于复杂，因为过复杂的哈希计算过程会消耗大量CPU，会导致计算效率降低。