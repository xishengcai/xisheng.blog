# 283. 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

 

**提示**:

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`

 

**进阶：**你能尽量减少完成的操作次数吗？



```
func moveZeroes(nums []int)  {
    // 找到0元素， 用i计数
    // 非0元素 保存至于 index-i
    // 0,1,0,2
    // i=2,l = 4, start=2
    l := len(nums)

    var i int
    for x:=0;x<l;x++{
        if nums[x] == 0{
            i++
        }else{
            nums[x-i]= nums[x]
        }
    }
    start :=  l-i
    for ;start<l;start++{
        nums[start] = 0
    }
}
```



### 方法一：双指针

思路及解法

使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。

右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

注意到以下性质：

​	1. 左指针左边均为非零数；

​	2. 右指针左边直到左指针处均为零。

因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。



```
func moveZeroes(nums []int) {
    left, right, n := 0, 0, len(nums)
    for right < n {
        if nums[right] != 0 {
            nums[left], nums[right] = nums[right], nums[left]
            left++
        }
        right++
    }
}
```



复杂度分析

时间复杂度：O(n)O(n)O(n)，其中 nnn 为序列长度。每个位置至多被遍历两次。

空间复杂度：O(1)O(1)O(1)。只需要常数的空间存放若干变量。

