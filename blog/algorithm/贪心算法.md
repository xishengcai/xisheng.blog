## [贪心算法](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2616926.html)

 

**1.定义概览**

贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解

算法思想：从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到某算法中的某一步不能再继续前进时，算法停止。

该算法存在问题：

1). 不能保证求得的最后解是最佳的；
2). 不能用来求最大或最小解问题；
3). 只能求满足某些约束条件的可行解的范围。

 Dijkstra算法、Prim算法和Kruskal算法都属于典型的贪心算法

 

**2.活动安排问题**

设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si <fi 。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。 

 

在下面所给出的解活动安排问题的贪心算法greedySelector :

```go
int greedySelector(int s[MAXNUM] , int f[MAXNUM], bool a[])  //s数组记录着相应活动开始时间，f数组记录着相应活动结束时间
{                                                            //各个活动按结束时间的非减序排列 
      int n=MAXNUM-1;
      a[1]=true;                                             //安排第一个活动
      int j=1,count=1;

      for (int i=2;i<=n;i++)
      {
        if (s[i]>=f[j])                                      //检验当前最早结束的活动的开始时间是否晚于前一个活动的结束结束时间
        {                                                    //如果晚于，则表示两个活动相互兼容
            a[i]=true;                                       //标记为true，表示已经安排
            j=i;                                             //记已经安排活动的个数
            count++;
        }
        else 
            a[i]=false;                                      //与已安排活动不兼容，标记此活动未安排
      }
      return count;
}
```

   由于输入的活动以其完成时间的非减序排列，所以算法greedySelector每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。

   算法greedySelector的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。

例：设待安排的11个活动的开始时间和结束时间按结束时间的非减序排列如下：

![img](https://pic002.cnblogs.com/images/2012/426620/2012073113562228.jpg)

![img](https://pic002.cnblogs.com/images/2012/426620/2012073113575543.jpg)

 

 

 

 

算法greedySelector 的计算过程如左图所示。图中每行相应于算法的一次迭代。阴影长条表示的活动是已选入集合A的活动，而空白长条表示的活动是当前正在检查相容性的活动。

 

   若被检查的活动i的开始时间Si小于最近选择的活动j的结束时间fi，则不选择活动i，否则选择活动i加入集合A中。

   贪心算法并不总能求得问题的整体最优解。但对于活动安排问题，贪心算法greedySelector却总能求得的整体最优解，即它最终所确定的相容活动集合A的规模最大。这个结论可以用数学归纳法证明。



**3.贪心算法基本要素**

**1).贪心选择性质**

贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素,也是贪心算法与动态规划算法的主要区别。

在动态规划算法中，每步所作的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能作出选择。而在贪心算法中，仅在当前状态下作出最好选择，即局部最优选择。然后再去解作出这个选择后产生的相应的子问题。贪心算法所作的贪心选择可以依赖于以往所作过的选择，但决不依赖于将来所作的选择，也不依赖于子问题的解。正是由于这种差别，动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行,以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为一个规模更小的子问题。

对于一个具体问题，要确定它是否具有贪心选择性质，我们必须证明每一步所作的贪心选择最终导致问题的一个整体最优解。通常可以用我们在证明活动安排问题的贪心选择性质时所采用的方法来证明。首先考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。而且作了贪心选择后，原问题简化为一个规模更小的类似子问题。然后，用数学归纳法证明，通过每一步作贪心选择，最终可得到问题的一个整体最优解。其中，证明贪心选择后的问题简化为规模更小的类似子问题的关键在于利用该问题的最优子结构性质。

 

**2).最优子结构性质**

当一个问题的最优解包含着它的子问题的最优解时，称此问题具有最优子结构性质。问题所具有的这个性质是该问题可用动态规划算法或贪心算法求解的一个关键特征。在活动安排问题中，其最优子结构性质表现为：若a是对于正的活动安排问题包含活动1的一个最优解,则相容活动集合a’=a—{1}是对于e’={i∈e:si≥f1}的活动安排问题的一个最优解。

 

**3).贪心算法与动态规划算法的差异**

贪心算法和动态规划算法都要求问题具有最优子结构性质，这是两类算法的一个共同点。大多数时候，能用贪心算法求解的问题，都可以用动态规划算法求解。但是能用动态规划求解的，不一定能用贪心算法进行求解。

 

**4.0-1背包问题和背包问题**

 

**1).两个问题的描述**

- **0-1背包问题：**

   给定n种物品和一个背包。物品i的重量是Wi，其价值为Vi，背包的容量为C。应如何选择装入背包的物品，使得装入背包中物品的总价值最大?

>    在选择装入背包的物品时，对每种物品i只有2种选择，即装入背包或不装入背包。不能将物品i装入背包多次，也不能只装入部分的物品i。

- **背包问题：**

   与0-1背包问题类似，所不同的是在选择物品i装入背包时，可以选择**物品i的一部分**，而不一定要全部装入背包，1≤i≤n。

这2类问题都具有最优子结构性质，极为相似，但背包问题可以用贪心算法求解，而0-1背包问题却不能用贪心算法求解。

 

**2).用贪心算法解背包问题的基本步骤：**

   首先计算每种物品单位重量的价值Vi/Wi，然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。若将这种物品全部装入背包后，背包内的物品总重量未超过C，则选择单位重量价值次高的物品并尽可能多地装入背包。依此策略一直地进行下去，直到背包装满为止。

代码实现：

```go
float knapsack(float c,float w[MAXNUM], float v[MAXNUM],float con[MAXNUM])
{
      int n=MAXNUM;
      float d[n],hascon=0,remain=c;

      int i;
      for (i = 0; i < n; i++) 
          d[i] = v[i]/w[i];                      //算出每个物品的平均价值

      sort(d,w,v,n);                             //按照平均价值对w,v进行排列，详细代码略

      for (i=0;i<n;i++)
          con[i]=0;                              //con记录第i个物品完整度，如果为0，未装入，如果为1整体装入 0，1之间装入部分

      for (i=0;i<n;i++) 
      {
          if (w[i]>remain )                      //如果第i个物品无法整体装进保 则跳出循环
                break;
          con[i]=1;
          hascon+=v[i]                           //累加装进包的物品总价值
          remain-=w[i];                          
      }
      if (i<n)
      {
           con[i]=remain/w[i];                   //计算包中剩余部分还能容纳多少价值 
           hascon+=con[i]*v[i];
       }

      return hascon;                             
}
```


   算法knapsack的主要计算时间在于将各种物品依其单位重量的价值从大到小排序。因此，算法的计算时间上界为O（nlogn）。当然，为了证明算法的正确性，还必须证明背包问题具有贪心选择性质。

   对于0-1背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。事实上，在考虑0-1背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择。由此就导出许多互相重叠的子问题。这正是该问题可用动态规划算法求解的另一重要特征。

   实际上也是如此，动态规划算法的确可以有效地解0-1背包问题。


5.贪心算法的适用范围:

贪心算法并不能总求得问题的整体最优解。但对于某些问题，却总能求得整体最优解，这要看问题时什么了。只要能满足贪心算法的两个性质：贪心选择性质和最优子结构性质，贪心算法就可以出色地求出问题的整体最优解。即使某些问题，贪心算法不能求得整体的最优解，贪心算法也能求出大概的整体最优解。如果你的要求不是太高，贪心算法是一个很好的选择。最优子结构性质是比较容易看出来的，但是贪心选择性质就没那么容易了，这个时候需要证明。证明往往使用数学归纳法。

