#### [46. 全排列](https://leetcode.cn/problems/permutations/)

难度中等2113

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

 

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**




【回溯法】采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答时，它将取消上一步甚至是上几步的计算，在通过其他的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

- 找到一个可能存在的正确答案
- 在尝试了所有可能的分步方法后宣告问题没有答案。

【深度优先搜索】Depth-First-Search，DFS 是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。当节点v的所在边都已被探寻过，搜索将 回溯 到发现节点v的那条边的起始节点。这一过程一直进行到已经发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。



**【与动态规划的区别】**

共同点

- 求解一个问题分为很多步骤
- 每一个步骤可以有多种选择

不同点

- 动态规划只需要球我们评估最优解是多少，最优解对应的具体解是什么并不要求
- 回溯法可以搜索得到所有的方案，但是本质上它是一种遍历算法，时间复杂度很高。

![image.png](https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png)

【从全排列问题开始理解回溯算法】

我们尝试在纸上写 3个数字、44个数字、5个数字的全排列，相信不难找到这样的方法。以数组 `[1, 2, 3]` 的全排列为例。







每个结点表示了求解全排列问题的不同阶段，这些阶段通过变量的【不同的值】体现，这些变量的不同的值，称之为【状态】；使用深度优先遍历有【回头】的过程，在【回头】以后，状态变量需要设置成为和先前一样，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称为【状态重置】；

【深度优先遍历】借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此path变量是一个栈。



深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。